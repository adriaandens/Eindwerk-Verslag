\subsection{gcc-3.3 installeren}
\begin{lstlisting}
http://credentiality2.blogspot.be/2009/04/fix-broken-ubuntu-gutsy-apt-get.html
     --> Bij gcc-3.3 is er nog geen sprake van stack protection.
\end{lstlisting}

\subsection{get env adres - programma}
getenvaddr.c uit Hacking boek onbruikbaar omwille van de randomisatie van de env var in het programma.

Oplossing 1?

Na lang zoeken is er het volgende naar voor gekomen:
\begin{lstlisting}
vagrant@lucid32:/vagrant/shellcode_oef$ ./getenvaddr SHELLCODE ./a.out 
SHELLCODE will be at 0xbfc3e8ea
vagrant@lucid32:/vagrant/shellcode_oef$ ./getenvaddr SHELLCODE ./a.out 
SHELLCODE will be at 0xbf9938ea
vagrant@lucid32:/vagrant/shellcode_oef$ ./getenvaddr SHELLCODE ./a.out 
SHELLCODE will be at 0xbfe138ea

8ea blijft constant, de rest zal veranderen
\end{lstlisting}

en nu? :'(

Oplossing:

ASLR afzetten.

\begin{lstlisting}
http://ubuntuforums.org/showthread.php?t=976656
\end{lstlisting}


\subsection{GCC stack smash detection}
\begin{lstlisting}
https://stackoverflow.com/questions/2340259/how-to-turn-off-gcc-compiler-optimization-to-enable-buffer-overflow
\end{lstlisting}

Bij het compileren van de c-code detecteert het OS onmiddellijk wanneer er een Buffer Overflow gebruikt wordt.

In Arch Linux krijgt je deze error niet.

Oplossing 1: NOPE
\begin{lstlisting}
gcc -fno-stack-protector -z execstack gebruiken
\end{lstlisting}

Oplossing 2: YES!!!

\begin{lstlisting}
Installeren van gcc3.3:

    http://ubuntuforums.org/showthread.php?t=1682774
    http://gcc.cybermirror.org/releases/
    http://credentiality2.blogspot.be/2009/04/fix-broken-ubuntu-gutsy-apt-get.html
\end{lstlisting}

Oplossing 3: NOPE

Live CD van hacking boek downloaden:

\begin{lstlisting}
http://evilzone.org/ebooks/hacking-the-art-of-exploitation-live-cd/

Geen connectie met internet mogelijk, dus geen ssh installeren.
Laptop: USB aanduiden ging ook niet. Moeten wachten tot 2e computer had & dan alles overzetten en daar lukte het wel om een USB aan te sluiten in de VM om zo de gemaakte oefeningen van Bufferoverflow over te zetten.
\end{lstlisting}

\subsection{Hoe nakijken of iemand correct heeft uitgevoerd?}
Vragen Bertels/phillipaerts (Sandbox???)

Wij geven een gecompileerd C programma die exploitbaar is. Zij schrijven op hun eigen computer een exploit programma in C. Deze loaden ze up onze server (via een webpagina). Dit start in de achtergrond een event die zorgt dat het exploitprogramma wordt nagekeken of deze juist is.

Probleem: Het compileren en uitvoeren van onbekende C code op een eigen server zonder dat deze alles kapot maakt met als doel nakijken of deze een gecompileerd programma kan exploiten.
\begin{itemize}
\item Operating system-level virtualization (\\(https://en.wikipedia.org/wiki/Jail\_\%28computer\_security\%29\#Implementations))
	\begin{itemize}
	\item chroot: zorgt ervoor dat ie geen andere programma's kan runnen dan nodig zijn (en ook geen bestanden bekijken buiten de chroot). Werkt niet tegen CPU en Memory use (en dus infinite loops of mallocs).
	\item FreeBSD jail: Lijkt een goede oplossing doordat elke oefening in een eigen jail draait (dus je kan zo verschillende oefeningen van elkaar scheiden) en er is support voor disablen van bepaalde functies en beperken van cpu tijd en memory.
	\item OpenVZ: (http://download.openvz.org/doc/openvz-intro.pdf) Lijkt ook heel handig. Voor elke oefening is er een template. Na elke oefening uit te voeren, deleten we de VE en starten we een nieuwe op als iemand nog eens code invoert. Opstarten van een nieuwe VE uit een template duurt blijkbaar slechts enkele seconden.
	\end{itemize}
\item Uitvoeren als gelimiteerde gebruiker met enkel rechten op 1 map met opgave en hun exploitcode. (nobody user in Linux?)
\end{itemize}
        
Probleem: Uitkomst printf'en. Meer uitleg: Bij sommige opdrachten is de tekst die geoutput wordt de manier om te kijken of het programma ``gekraakt'' is. We willen echter dat de gebruiker niet gewoon printf(``Output string'') kan doen om te simuleren dat hij het programma heeft ge-exploit.

\begin{itemize}
\item Een zeer slim programma schrijven die de (exploit) C code kan interpreteren en verstaan.
\end{itemize}
    
Probleem: Gebruik van zaken die helemaal niet nodig zijn (met sockets werken, bepaalde files proberen te bereiken)

\begin{itemize}
\item Regex'en op "\#include" statements en slechts enkele toelaten (stdio.h, string.h, ...) afhankelijk van de oefening. 
\end{itemize}
Andere oplossingen?


\subsection{Bufferoverflows - oef6}
Array-entries worden normaal (van begin --\textgreater einde) beschreven, dus overschrijven van array-entry met behulp van langere filenaam zal niet werken...

Oplossen: eerst aantal files opvragen, dan van array beschrijven van laatste naar eerste --\textgreater overschrijven moet nu wel gaan

\subsection{Probleem: shellcode ELF}

nasm -f elf helloworld.asm ld helloworld.o
\begin{lstlisting}
ld: i386 architecture of input file `helloworld.o' is incompatible with i386:x86-64 output
\end{lstlisting}

Oplossing:
\begin{lstlisting}
nasm -f elf64 helloworld.asm
ld helloworld.o
\end{lstlisting}
    

\subsection{Probleem: EB1E}
\begin{lstlisting}
00000000 EB1E ; jmp short 0x20
..
00000020 E8DDFFFFFF ; call dword 0x02
00000030
00000033
\end{lstlisting}
    

\subsection{Probleem: 1E}
\begin{lstlisting}
1E = 30 decimaal maar er staat jmp 20?
\end{lstlisting}
    
Oplossing:
\begin{lstlisting}
1E = 30
20 = 32
\end{lstlisting}
De haal/fetch cyclus zorgt ervoor dat als dit bevel aan de beurt komt, de bevelenteller eerst omhoog gaat voordat ie uitgevoerd wordt. dus EIP = 0x02. Je moet dan nog 1E naar beneden. (30) En dan kan je idd uit bij de call instructie 0x20.